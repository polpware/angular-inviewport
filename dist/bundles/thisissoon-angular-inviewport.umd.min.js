!(function(t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(
        exports,
        require('@angular/core'),
        require('rxjs'),
        require('rxjs/operators')
      )
    : 'function' == typeof define && define.amd
      ? define('@thisissoon/angular-inviewport', [
          'exports',
          '@angular/core',
          'rxjs',
          'rxjs/operators'
        ], e)
      : e(
          ((t.thisissoon = t.thisissoon || {}),
          (t.thisissoon['angular-inviewport'] = {})),
          t.ng.core,
          t.rxjs,
          t.Rx.Observable.prototype
        );
})(this, function(t, r, i, e) {
  'use strict';
  var n = (function() {
    function t() {
      (this.closed = null),
        (this.defaultStatus = null),
        (this.document = null),
        (this.frameElement = null),
        (this.frames = null),
        (this.history = null),
        (this.innerHeight = null),
        (this.innerWidth = null),
        (this.length = null),
        (this.localStorage = null),
        (this.location = null),
        (this.name = null),
        (this.navigator = null),
        (this.opener = null),
        (this.outerHeight = null),
        (this.outerWidth = null),
        (this.pageXOffsetleft = null),
        (this.pageYOffsetleft = null),
        (this.parent = null),
        (this.screen = null),
        (this.screenLeft = null),
        (this.screenTop = null),
        (this.screenX = null),
        (this.screenY = null),
        (this.sessionStorage = null),
        (this.scrollX = null),
        (this.scrollY = null),
        (this.self = null),
        (this.status = null),
        (this.top = null);
    }
    return (
      (t.prototype.addEventListener = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.alert = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.atob = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.blur = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.btoa = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.clearInterval = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.clearTimeout = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.close = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.confirm = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.focus = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.getComputedStyle = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.getSelection = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.matchMedia = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.moveBy = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.moveTo = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.open = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.print = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.prompt = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.resizeBy = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.resizeTo = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.removeEventListener = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.scroll = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.scrollBy = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.scrollTo = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.setInterval = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.setTimeout = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      (t.prototype.stop = function() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      }),
      t
    );
  })();
  n.decorators = [{ type: r.Injectable }];
  var o = 'resize',
    s = 'scroll',
    l = 'class.sn-viewport-in',
    p = 'class.sn-viewport-out',
    u = 'scroll',
    a = (function() {
      function t(t, e, n, o) {
        (this.el = t),
          (this.windowRef = e),
          (this.cdRef = n),
          (this.ngZone = o),
          (this.viewport$ = new i.Subject()),
          (this.ngUnsubscribe$ = new i.Subject()),
          (this.inViewportChange = new r.EventEmitter()),
          (this.debounce = 100);
      }
      return (
        Object.defineProperty(t.prototype, 'isInViewport', {
          get: function() {
            return this.inViewport;
          },
          enumerable: !0,
          configurable: !0
        }),
        Object.defineProperty(t.prototype, 'isNotInViewport', {
          get: function() {
            return !this.inViewport;
          },
          enumerable: !0,
          configurable: !0
        }),
        Object.defineProperty(t.prototype, 'viewport', {
          get: function() {
            return {
              bottom: this.windowRef.innerHeight,
              right: this.windowRef.innerWidth,
              left: 0,
              top: 0
            };
          },
          enumerable: !0,
          configurable: !0
        }),
        (t.prototype.ngAfterViewInit = function() {
          var t = this;
          this.calculateInViewportStatus(),
            this.cdRef.detectChanges(),
            this.viewport$
              .pipe(
                e.debounceTime(this.debounce),
                e.takeUntil(this.ngUnsubscribe$)
              )
              .subscribe(function() {
                return t.calculateInViewportStatus();
              }),
            this.ngZone.runOutsideAngular(function() {
              i.merge(i.fromEvent(t.windowRef, o), i.fromEvent(t.windowRef, s))
                .pipe(
                  e.auditTime(t.debounce),
                  e.takeUntil(t.ngUnsubscribe$)
                )
                .subscribe(function() {
                  return t.onViewportChange();
                });
            }),
            this.parent &&
              this.ngZone.runOutsideAngular(function() {
                i.fromEvent(t.parent, u)
                  .pipe(
                    e.auditTime(t.debounce),
                    e.takeUntil(t.ngUnsubscribe$)
                  )
                  .subscribe(function() {
                    return t.onParentScroll();
                  });
              });
        }),
        (t.prototype.onParentScroll = function() {
          this.viewport$.next();
        }),
        (t.prototype.onViewportChange = function() {
          this.viewport$.next();
        }),
        (t.prototype.calculateInViewportStatus = function() {
          var t = this,
            e = this.el.nativeElement,
            n = !1,
            o = !1;
          if (this.parent) {
            var r = this.parent.getBoundingClientRect();
            (n = this.isInElementViewport(r, e)),
              (o = this.isInElementViewport(this.viewport, this.parent));
          } else (n = !0), (o = this.isInElementViewport(this.viewport, e));
          var i = this.inViewport;
          (this.inViewport = n && o),
            i !== this.inViewport &&
              this.ngZone.run(function() {
                return t.inViewportChange.emit(t.inViewport);
              });
        }),
        (t.prototype.isInElementViewport = function(t, e) {
          if ('function' == typeof e.getBoundingClientRect) {
            var n = e.getBoundingClientRect();
            return (
              ((n.top >= t.top && n.top <= t.bottom) ||
                (n.bottom >= t.top && n.bottom <= t.bottom) ||
                (n.top <= t.top && n.bottom >= t.bottom)) &&
              ((n.left >= t.left && n.left <= t.right) ||
                (n.right >= t.left && n.right <= t.right) ||
                (n.left <= t.left && n.right >= t.right))
            );
          }
          return !1;
        }),
        (t.prototype.ngOnDestroy = function() {
          this.ngUnsubscribe$.next(), this.ngUnsubscribe$.complete();
        }),
        t
      );
    })();
  (a.decorators = [
    {
      type: r.Directive,
      args: [{ selector: '[snInViewport]', exportAs: 'snInViewport' }]
    }
  ]),
    (a.ctorParameters = function() {
      return [
        { type: r.ElementRef },
        { type: n },
        { type: r.ChangeDetectorRef },
        { type: r.NgZone }
      ];
    }),
    (a.propDecorators = {
      inViewportChange: [{ type: r.Output }],
      debounce: [{ type: r.Input }],
      parent: [{ type: r.Input }],
      isInViewport: [{ type: r.HostBinding, args: [l] }],
      isNotInViewport: [{ type: r.HostBinding, args: [p] }]
    });
  var c = [n],
    f = (function() {
      function e() {}
      return (
        (e.forRoot = function(t) {
          return void 0 === t && (t = c), { ngModule: e, providers: t };
        }),
        e
      );
    })();
  (f.decorators = [
    { type: r.NgModule, args: [{ declarations: [a], exports: [a] }] }
  ]),
    (t.InViewportModule = f),
    (t.InViewportDirective = a),
    (t.eventPathResize = [
      '$event.target.innerHeight',
      '$event.target.innerWidth',
      '$event.target.scrollY',
      '$event.target.scrollX'
    ]),
    (t.eventPathScroll = [
      '$event.target.defaultView.innerHeight',
      '$event.target.defaultView.innerWidth',
      '$event.target.defaultView.scrollY',
      '$event.target.defaultView.scrollX'
    ]),
    (t.eventScroll = u),
    (t.eventWindowResize = o),
    (t.eventWindowScroll = s),
    (t.inViewportClass = l),
    (t.notInViewportClass = p),
    (t.WindowRef = n),
    Object.defineProperty(t, '__esModule', { value: !0 });
});
//# sourceMappingURL=thisissoon-angular-inviewport.umd.min.js.map
